<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gabe's Blog</title>
    <description>Some Nerd's blog/portfolio/soapbox
</description>
    <link>http://gabcoh.github.io/</link>
    <atom:link href="http://gabcoh.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 15 Aug 2016 18:48:30 -0500</pubDate>
    <lastBuildDate>Mon, 15 Aug 2016 18:48:30 -0500</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>TUCTF 2016: Secure Auth</title>
        <description>&lt;p&gt;(the entire TUCTF server vm is available &lt;a href=&quot;http://ctf.asciioverflow.com/general/2016/07/06/tuctf-2016.html&quot;&gt;here&lt;/a&gt; for you to try yourself!)&lt;/p&gt;

&lt;h2 id=&quot;problem&quot;&gt;problem&lt;/h2&gt;
&lt;p&gt;We have set up this fancy automatic signing server!
We also uses RSA authentication, so it’s super secure!&lt;/p&gt;

&lt;p&gt;Note: the program accepts base 10 numbers&lt;/p&gt;

&lt;p&gt;nc ip 54321&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;solution&lt;/h2&gt;
&lt;p&gt;We are given an adress to a server which will take in a base $10$ number, $p$, and 
spew out its signature under a secret key, (which is consistent through each connection).
In order to obtain the flag, we must fabricate a signature of some given text (which is 
consistent through each connection as well) without knowledge of that secret key.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-code&quot; data-lang=&quot;code&quot;&gt;[~/Desktop/TUCTF/Secure Auth]$ nc localhost 54321
Welcome to RSA authentication!
give me message to sign:
1337
Sure, I will sign that:
24195239458979699814515643667745488307009666060906284589653572343732496036671541067477240368640363014611610224365976889729278981425957282344433845609033080579634431864524813352427223228644196625293716265834345147724004053496852870231296068530298484902167232292389305130171937112437540332996206250872441967575617690817313476692751213554658580543352834366970567389472904089183540834654519699514023157226940529856894776904710397342114626311916892110954668315838171395358297415528982446775781114694488159167708305234231957681598843266910411384223366629754727059748008575633529517626464327881524046866382865741412801579850
Only authorized people can view the flag
give me a signature for get_your_hands_off_my_RSA!:&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To recap, right now all we have been given is a function $S(p)$ which computes 
$p^d\pmod N$ and we need to find $S(p)$, where p is the decimal representation of the string&lt;/p&gt;

&lt;center&gt;&lt;code&gt;get_your_hands_off_my_RSA!&lt;/code&gt;&lt;/center&gt;

&lt;p&gt;Great!!!
So all we need to do is find the decimal representation of that string, let’s call it $q$, 
and pass it to the server to compute $S(q)$, aka it’s RSA digital signature.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;  &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'get_your_hands_off_my_RSA!'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'hex'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;il&quot;&gt;166151459290300546021127823915547539196280244544484032717734177L&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-code&quot; data-lang=&quot;code&quot;&gt;[~/Desktop/TUCTF/Secure Auth]$ nc localhost 54321
Welcome to RSA authentication!
give me message to sign:
166151459290300546021127823915547539196280244544484032717734177
hey that is cheating!!! I won't sign that...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ha! If only it were that easy…&lt;/p&gt;

&lt;p&gt;So clearly we’ll have to be a little more clever. To defeat this we
will use a variation of a blinding attack (sort of). 
Lets have $N$ be the modulus used by the server, $q$ be the message for which we want to fabricate a signature, and $r$ be a divisor of $q$.
The attack works as follows:&lt;/p&gt;

&lt;p&gt;Determine $N$ by signing -1 and adding 1 to the result.&lt;/p&gt;
&lt;center&gt;$e\equiv 1\pmod 2 \iff (-1)^e\equiv N - 1\pmod N$&lt;/center&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-code&quot; data-lang=&quot;code&quot;&gt;[~/Desktop/TUCTF/Secure Auth]$ nc localhost 54321
Welcome to RSA authentication!
give me message to sign:
-1
Sure, I will sign that:
24690625680063774371747714092931245796723840632401231916590850908498671935961736332195862060536688021640067386108834202275189822898599594463635840996761025690456263370146016114156010619769568905940572317842895114700949532134039597475463182795837468991755433866386124620786221838783092089725622611582198259472856998222335236408416769316026577935933861556358082075245487480828539893580743606793508167690532131893625600405714820107050359744864841126038929638426613876368411017300987682339192115588614533886473808385041303878518137898225847735216970008990188644891634667174415391598670430735870182014445537116749235017326&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, it is trivial to chose a factor of $q$, in this case we will chose $r=3$.
We now must compute $r^\prime=S(r)$, and $q^\prime=S(q\div r)$.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-plain&quot; data-lang=&quot;plain&quot;&gt;[~/Desktop/TUCTF/Secure Auth]$ nc localhost 54321
Welcome to RSA authentication!
give me message to sign:
3
Sure, I will sign that:
241662300412370597870887401575310468638815644028805557874150940710375052128062439804477387620744376137350983344903937679093747405982227134597589908813493092662351037292887937645686464128877024348142601870
771981536943490466645883149303628928082743029654476866727457943044945850287041499947181484825080627594479426752216278096138103719928982364072504099619820964109899203963156138777869349112576145447252096504
905554389721851932627716906288222180950379393046605087045638117577060989526215739199524225574818902985830712260999621879294571268728287750784238702955204024905618170358062442043597363890209350580183560398
55243
Only authorized people can view the flag
give me a signature for get_your_hands_off_my_RSA!:^C
[~/Desktop/TUCTF/Secure Auth]$ nc localhost 54321
Welcome to RSA authentication!
give me message to sign:
55383819763433515340375941305182513065426748181494677572578059
Sure, I will sign that:
148859930019323751741706762004835863694780094076684325874944911690039154827357991789528156509750839500485865038011822705017291650030136519574453407913735232003384075876031062018056887800213001477803001536
425238903213306979228509039714168962910002401322670143495308644727391617908845100208872950291666090037410987724612559786369109253137687224740934643169786958240241358814213560134957178665146805340871760216
930131801957520835755500937073294184790590115466714632441879712704131826082544349741703439870301890832140087059122972689670862530890097005586982498562562320614115152404361703517538584564094888566160674986
31584
Only authorized people can view the flag
give me a signature for get_your_hands_off_my_RSA!:&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is all of the information we need to complete the attack.
Finally, $S(q) = r^\prime \times q^\prime \pmod N$&lt;/p&gt;

&lt;p&gt;And after passing $S(q)$ to the server, we get our flag.&lt;/p&gt;
&lt;center&gt;&lt;code&gt;TUCTF{I'm_b1inded_6y_7h3_light}&lt;/code&gt;&lt;/center&gt;

&lt;h1 id=&quot;proof&quot;&gt;proof&lt;/h1&gt;
&lt;p&gt;$
t \mid q \implies q^d = ((q\div t)\times t)^d = (q\div t)^d \times t^d \pmod N 
$&lt;/p&gt;

</description>
        <pubDate>Tue, 09 Aug 2016 00:00:00 -0500</pubDate>
        <link>http://gabcoh.github.io/2016/08/09/Secure_Auth.html</link>
        <guid isPermaLink="true">http://gabcoh.github.io/2016/08/09/Secure_Auth.html</guid>
        
        <category>ctf</category>
        
        <category>tuctf_2016</category>
        
        <category>writeup</category>
        
        
      </item>
    
      <item>
        <title>ABCTF 2016: a small broadcast</title>
        <description>&lt;h1 id=&quot;problem&quot;&gt;problem&lt;/h1&gt;
&lt;p&gt;I RSA encrypted the same message 3 different times with the same exponent. Can you decrypt &lt;a href=&quot;http://gabcoh.github.io/assets/abctf_2016/a_small_broadcast/broadcast.txt&quot;&gt;this&lt;/a&gt;?&lt;/p&gt;

&lt;h1 id=&quot;solution&quot;&gt;solution&lt;/h1&gt;
&lt;p&gt;As usual, my first instinct in attempting to solve this problem was to 
just factor the modulus using &lt;a href=&quot;https://github.com/radii/msieve&quot;&gt;msieve&lt;/a&gt;. But, a quick test reveals that 
the moduli are to large for msieve to even attempt to factor &lt;em&gt;(on the order 1024 bits)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A quick google of &lt;em&gt;a small broadcast rsa&lt;/em&gt; reveals the wikipedia page
for &lt;a href=&quot;https://en.wikipedia.org/wiki/Coppersmith%27s_attack&quot;&gt;Coppersmith’s attack&lt;/a&gt;. &lt;strong&gt;Håstad’s broadcast attack&lt;/strong&gt; on this page immediatly jumps
out at me for its simmilarity with the name of this problem. Further reading 
confirms this hunch. &lt;strong&gt;Håstad’s broadcast attack&lt;/strong&gt; is exactly what we need.&lt;/p&gt;

&lt;p&gt;Put simply this attack hinges on the &lt;strong&gt;Chinese Remainders Theorem&lt;/strong&gt;;
a thousand year old identity that proves recreational math has far 
reaching implications unfathomable at the time of it’s discovery.&lt;/p&gt;

&lt;p&gt;To understand the &lt;strong&gt;CRT’s&lt;/strong&gt; relavence to this problem we must first recall both the &lt;strong&gt;Textbook RSA
function&lt;/strong&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p^e\equiv C\pmod N&lt;/script&gt;

&lt;p&gt;and that we are given three of these pairs in which $p$ and $e$ 
are held constant.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Chinese Remainder Theorem&lt;/strong&gt; tells us that given&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x\equiv a_1\pmod{N_1}\\
  \vdots\\
  x\equiv a_i\pmod{N_i}&lt;/script&gt;

&lt;p&gt;we can uniquely determine x. This is great news because this is the exact situation we are in.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p^e\equiv C_1\pmod{N_1}\\
  \vdots\\
  p^e\equiv C_3\pmod{N_3}&lt;/script&gt;

&lt;p&gt;With Some more searching I found that one of my favorite &lt;a href=&quot;https://hackage.haskell.org/package/arithmoi-0.4.2.0/docs/Math-NumberTheory-Moduli.html#v:chineseRemainder&quot;&gt;haskell libraries&lt;/a&gt;
already has a function to compute $x$ or $p^e$ from Eq. 2 and 3.&lt;/p&gt;

&lt;p&gt;So, after a bit of proccessing and guessing at the public key (it ends up being 3!!!) 
we end up with the flag (&lt;a href=&quot;http://gabcoh.github.io/assets/abctf_2016/a_small_broadcast/chinese.hs&quot;&gt;code&lt;/a&gt;):&lt;/p&gt;

&lt;center&gt;&lt;code&gt;abctf{ch!n3s3_rema1nd3r_the0rem_is_to0_op_4_m3}&lt;/code&gt;&lt;/center&gt;

&lt;p&gt;ps.&lt;/p&gt;

&lt;p&gt;      sorry for using haskell. email me for any questions on how the program works!&lt;/p&gt;

</description>
        <pubDate>Mon, 08 Aug 2016 00:00:00 -0500</pubDate>
        <link>http://gabcoh.github.io/2016/08/08/a_small_broadcast.html</link>
        <guid isPermaLink="true">http://gabcoh.github.io/2016/08/08/a_small_broadcast.html</guid>
        
        <category>ctf</category>
        
        <category>abctf_2016</category>
        
        <category>writeup</category>
        
        
      </item>
    
  </channel>
</rss>
